<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="icon" href="tripode.ico">
    <link rel="stylesheet" href="main.css">
    <style>
        body {
            margin: 0;
            background-color:aquamarine;
        }

        #glcanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }
    </style>
</head>

<body>

    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aVertexPosition;
        attribute vec2 aTexturePosition;
         
         
        varying vec2 tPos;
         
        void main() {
            tPos = aTexturePosition;
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
        }
        </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
            #define TAU 6.28318530718
            #define TILING_FACTOR 1.0
            #define MAX_ITER 8

            #ifdef GL_ES
                precision highp float;
            #endif
             
            uniform float u_time;
            varying vec2 tPos;

            float waterHighlight(vec2 p, float time, float foaminess)
            {
                vec2 i = vec2(p);
                float c = 0.0;
                float foaminess_factor = mix(1.0, 6.0, foaminess);
                float inten = .005 * foaminess_factor;

                for (int n = 0; n < MAX_ITER; n++) 
                {
                    float t = time * (1.0 - (3.5 / float(n+1)));
                    i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                    c += 1.0/length(vec2(p.x / (sin(i.x+t)),p.y / (cos(i.y+t))));
                }
                c = 0.2 + c / (inten * float(MAX_ITER));
                c = 1.17-pow(c, 1.4);
                c = pow(abs(c), 8.0);
                return c / sqrt(foaminess_factor);
            }



            float rand(float co){
                return fract(sin(dot(vec2(co, co + 0.2) , vec2(12.9898, 78.233))) * 43758.5453);
            }
            float rand2(float co){
                return fract(sin(dot(vec2(co, co + 0.2) , vec2(9.9898, 83.233))) * 33758.5453);
            }
            void main(void) {
                vec2 resolution = vec2(1., 1.);
                
                float time = u_time * 0.0001+23.0;
                vec2 uv = tPos.xy / resolution.xy;
                vec2 uv_square = vec2(uv.x * resolution.x / resolution.y, uv.y);
                float dist_center = pow(2.0*length(uv - 0.5), 2.0);
                
                float foaminess = smoothstep(0.4, 1.8, dist_center);
                float clearness = 0.1 + 0.9*smoothstep(0.1, 0.5, dist_center);
                
                vec2 p = mod(uv_square*TAU*TILING_FACTOR, TAU)-250.0;
                
                float c = waterHighlight(p, time, foaminess);
                
                vec3 water_color = vec3(0.0, 0.35, 0.5);
                vec3 color = vec3(c);
                color = clamp(color + water_color, 0.0, 1.0);
                
                color = mix(water_color, color, clearness);

                gl_FragColor = vec4(color, 1.0);






            }
            </script>

    <script>
        let gl = null;
        let glCanvas = null;
        let timeStart;

        function initwebGL() {
            glCanvas = document.getElementById("glcanvas");
            gl = glCanvas.getContext("webgl");
        }


        function compileShader(id, type) {
            let code = document.getElementById(id).firstChild.nodeValue;
            let shader = gl.createShader(type);

            gl.shaderSource(shader, code);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log(`Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`);
                console.log(gl.getShaderInfoLog(shader));
                alert("Error compiling shader");
            }
            return shader;
        }

        function buildShaderProgram(shaderInfo, uniforms, attributes) {
            let program = gl.createProgram();

            shaderInfo.forEach(function (desc) {
                let shader = compileShader(desc.id, desc.type);

                if (shader) {
                    gl.attachShader(program, shader);
                }
                else {
                    alert("Error attaching shader");
                }
            });

            gl.linkProgram(program)

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert("Error linking shader program");
                console.log("Error linking shader program:");
                console.log(gl.getProgramInfoLog(program));
            }

            var unifrorms_dict = {}
            uniforms.forEach(function (name) {
                uniform_id = gl.getUniformLocation(program, name);
                unifrorms_dict[name] = uniform_id;
            });

            var attributes_dict = {}
            attributes.forEach(function (name) {
                attrib_id = gl.getAttribLocation(program, name);
                attributes_dict[name] = attrib_id;
            });

            return {
                program: program,
                uniforms: unifrorms_dict,
                attributes: attributes_dict
            };
        }


        // Vertex information
        let vertexBuffer;
        let vertexCount;

        window.addEventListener("load", startup, false);

        function startup() {
            timeStart = Date.now();
            initwebGL();

            const shaderSet = [
                {
                    type: gl.VERTEX_SHADER,
                    id: "vertex-shader"
                },
                {
                    type: gl.FRAGMENT_SHADER,
                    id: "fragment-shader"
                }
            ];
            const shaderUniforms = [
                "u_time"
            ];
            const shaderAttributes = [
                "aVertexPosition",
                "aTexturePosition"
            ];
            shaderProgram = buildShaderProgram(shaderSet,
                shaderUniforms,
                shaderAttributes);
            console.log(shaderProgram)

            // Here are attributes for 4 vertices (one per line):
            // - The first two numbers are vertex positions.
            // - The second two numbers are texture positions.
            let vertices = new Float32Array([
                -1, 1, 0, 0,
                1, 1, 1, 0,
                -1, -1, 0, 1,
                1, -1, 1, 1
            ]);

            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            vertexCount = vertices.length / 4;

            animateScene();
        }

        function resize(canvas) {
            // Look up the size the browser is displaying the canvas.
            var displayWidth = window.innerWidth;
            var displayHeight = window.innerHeight;

            // Check if the canvas has different size and make it the same.
            if (canvas.width !== displayWidth ||
                canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }
        }

        function animateScene() {
            // We need an actual window size for correctly viewport setup.
            resize(glCanvas);

            // Setup viewport and clear it with black non transparent colour.
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Select a buffer for vertices attributes.
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            // Enable and setup attributes.
            gl.enableVertexAttribArray(shaderProgram.attributes["aVertexPosition"]);
            gl.vertexAttribPointer(shaderProgram.attributes["aVertexPosition"], 2,
                gl.FLOAT, false, 4 * 4, 0);
            gl.enableVertexAttribArray(shaderProgram.attributes["aTexturePosition"]);
            gl.vertexAttribPointer(shaderProgram.attributes["aTexturePosition"], 2,
                gl.FLOAT, false, 4 * 4, 2 * 4);


            gl.uniform1f(shaderProgram.uniforms["u_time"], Date.now() - timeStart);

            // Select shader program.
            gl.useProgram(shaderProgram.program);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexCount);


            window.requestAnimationFrame(function (currentTime) {
                console.log("Animate", Date.now() - timeStart)
                previousTime = currentTime;
                animateScene();
            });
        }

    </script>

</body>

</html>