<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="tripode.ico" />
    <link rel="stylesheet" href="main.css" />
    <style>
      body {
        margin: 0;
      }

      #glcanvas {
        position: absolute;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
      }
    </style>
  </head>

  <body>
    <canvas id="glcanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
      attribute vec3 position;
      attribute vec2 uv;

      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = vec4(position, 1.0);
      }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
      precision highp float;

      uniform float u_time;
      uniform vec2 u_resolution;
      uniform sampler2D u_texture;

      varying vec2 vUv;

      float random(vec2 c){
        return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }

      //
      // Description : Array and textureless GLSL 2D/3D/4D simplex
      //               noise functions.
      //      Author : Ian McEwan, Ashima Arts.
      //  Maintainer : ijm
      //     Lastmod : 20110822 (ijm)
      //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
      //               Distributed under the MIT License. See LICENSE file.
      //               https://github.com/ashima/webgl-noise
      //

      vec3 mod289(vec3 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 mod289(vec4 x) {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      vec4 permute(vec4 x) {
           return mod289(((x*34.0)+1.0)*x);
      }

      vec4 taylorInvSqrt(vec4 r)
      {
        return 1.79284291400159 - 0.85373472095314 * r;
      }

      float snoise3(vec3 v)
        {
        const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

      // First corner
        vec3 i  = floor(v + dot(v, C.yyy) );
        vec3 x0 =   v - i + dot(i, C.xxx) ;

      // Other corners
        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min( g.xyz, l.zxy );
        vec3 i2 = max( g.xyz, l.zxy );

        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
        //   x1 = x0 - i1  + 1.0 * C.xxx;
        //   x2 = x0 - i2  + 2.0 * C.xxx;
        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
        vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

      // Permutations
        i = mod289(i);
        vec4 p = permute( permute( permute(
                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                 + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

      // Gradients: 7x7 points over a square, mapped onto an octahedron.
      // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        float n_ = 0.142857142857; // 1.0/7.0
        vec3  ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

        vec4 x = x_ *ns.x + ns.yyyy;
        vec4 y = y_ *ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4( x.xy, y.xy );
        vec4 b1 = vec4( x.zw, y.zw );

        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
        vec4 s0 = floor(b0)*2.0 + 1.0;
        vec4 s1 = floor(b1)*2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

        vec3 p0 = vec3(a0.xy,h.x);
        vec3 p1 = vec3(a0.zw,h.y);
        vec3 p2 = vec3(a1.xy,h.z);
        vec3 p3 = vec3(a1.zw,h.w);

      //Normalise gradients
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

      // Mix final noise value
        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                      dot(p2,x2), dot(p3,x3) ) );
        }

      const float interval = 3.0;

      void main(void){
        float strength = smoothstep(interval * 0.5, interval, interval - mod(u_time, interval));
        vec2 shake = vec2(strength * 8.0 + 0.5) * vec2(
          random(vec2(u_time)) * 2.0 - 1.0,
          random(vec2(u_time * 2.0)) * 2.0 - 1.0
        ) / u_resolution;

        float y = vUv.y * u_resolution.y;
        float rgbWave = (
            snoise3(vec3(0.0, y * 0.01, u_time * 400.0)) * (2.0 + strength * 32.0)
            * snoise3(vec3(0.0, y * 0.02, u_time * 200.0)) * (1.0 + strength * 4.0)
            + step(0.9995, sin(y * 0.005 + u_time * 1.6)) * 12.0
            + step(0.9999, sin(y * 0.005 + u_time * 2.0)) * -18.0
          ) / u_resolution.x;
        float rgbDiff = (6.0 + sin(u_time * 500.0 + vUv.y * 40.0) * (20.0 * strength + 1.0)) / u_resolution.x;
        float rgbUvX = vUv.x + rgbWave;
        float r = texture2D(u_texture, vec2(rgbUvX + rgbDiff, vUv.y) + shake).r;
        float g = texture2D(u_texture, vec2(rgbUvX, vUv.y) + shake).g;
        float b = texture2D(u_texture, vec2(rgbUvX - rgbDiff, vUv.y) + shake).b;

        float whiteNoise = (random(vUv + mod(u_time, 10.0)) * 2.0 - 1.0) * (0.15 + strength * 0.15);

        float bnTime = floor(u_time * 20.0) * 200.0;
        float noiseX = step((snoise3(vec3(0.0, vUv.x * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);
        float noiseY = step((snoise3(vec3(0.0, vUv.y * 3.0, bnTime)) + 1.0) / 2.0, 0.12 + strength * 0.3);
        float bnMask = noiseX * noiseY;
        float bnUvX = vUv.x + sin(bnTime) * 0.2 + rgbWave;
        float bnR = texture2D(u_texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask;
        float bnG = texture2D(u_texture, vec2(bnUvX, vUv.y)).g * bnMask;
        float bnB = texture2D(u_texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask;
        vec4 blockNoise = vec4(bnR, bnG, bnB, 1.0);

        float bnTime2 = floor(u_time * 25.0) * 300.0;
        float noiseX2 = step((snoise3(vec3(0.0, vUv.x * 2.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.5);
        float noiseY2 = step((snoise3(vec3(0.0, vUv.y * 8.0, bnTime2)) + 1.0) / 2.0, 0.12 + strength * 0.3);
        float bnMask2 = noiseX2 * noiseY2;
        float bnR2 = texture2D(u_texture, vec2(bnUvX + rgbDiff, vUv.y)).r * bnMask2;
        float bnG2 = texture2D(u_texture, vec2(bnUvX, vUv.y)).g * bnMask2;
        float bnB2 = texture2D(u_texture, vec2(bnUvX - rgbDiff, vUv.y)).b * bnMask2;
        vec4 blockNoise2 = vec4(bnR2, bnG2, bnB2, 1.0);

        float waveNoise = (sin(vUv.y * 1200.0) + 1.0) / 2.0 * (0.15 + strength * 0.2);

        gl_FragColor = vec4(r, g, b, 1.0) * (1.0 - bnMask - bnMask2) + (whiteNoise + blockNoise + blockNoise2 - waveNoise);
      }
    </script>

    <script>
      let gl = null;
      let glCanvas = null;
      let timeStart;

      function initwebGL() {
        glCanvas = document.getElementById("glcanvas");
        gl = glCanvas.getContext("webgl");
      }

      function compileShader(id, type) {
        let code = document.getElementById(id).firstChild.nodeValue;
        let shader = gl.createShader(type);

        gl.shaderSource(shader, code);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.log(
            `Error compiling ${
              type === gl.VERTEX_SHADER ? "vertex" : "fragment"
            } shader:`
          );
          console.log(gl.getShaderInfoLog(shader));
          alert("Error compiling shader");
        }
        return shader;
      }

      function buildShaderProgram(shaderInfo, uniforms, attributes) {
        let program = gl.createProgram();

        shaderInfo.forEach(function (desc) {
          let shader = compileShader(desc.id, desc.type);

          if (shader) {
            gl.attachShader(program, shader);
          } else {
            alert("Error attaching shader");
          }
        });

        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          alert("Error linking shader program");
          console.log("Error linking shader program:");
          console.log(gl.getProgramInfoLog(program));
        }

        var unifrorms_dict = {};
        uniforms.forEach(function (name) {
          uniform_id = gl.getUniformLocation(program, name);
          unifrorms_dict[name] = uniform_id;
        });

        var attributes_dict = {};
        attributes.forEach(function (name) {
          attrib_id = gl.getAttribLocation(program, name);
          attributes_dict[name] = attrib_id;
        });

        return {
          program: program,
          uniforms: unifrorms_dict,
          attributes: attributes_dict,
        };
      }

      // Vertex information
      let vertexBuffer;
      let vertexCount;

      window.addEventListener(
        "load",
        () => {
          var image = new Image();
          //   image.crossOrigin = ""
          image.onload = function () {
            // render(image);
            console.log("loaded");
            startup(image);
          };
          image.src = "./image.png"; // MUST BE SAME DOMAIN!!!
          console.log("wtf");
        },

        false
      );

      function startup(image) {
        timeStart = Date.now();
        initwebGL();

        const shaderSet = [
          {
            type: gl.VERTEX_SHADER,
            id: "vertex-shader",
          },
          {
            type: gl.FRAGMENT_SHADER,
            id: "fragment-shader",
          },
        ];
        const shaderUniforms = ["u_time", "u_resolution", "u_texture"];
        const shaderAttributes = ["aVertexPosition", "aTexturePosition"];
        shaderProgram = buildShaderProgram(
          shaderSet,
          shaderUniforms,
          shaderAttributes
        );
        console.log(shaderProgram);

        // Here are attributes for 4 vertices (one per line):
        // - The first two numbers are vertex positions.
        // - The second two numbers are texture positions.
        let vertices = new Float32Array([
          -1, 1, 0, 0, 1, 1, 1, 0, -1, -1, 0, 1, 1, -1, 1, 1,
        ]);

        vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        vertexCount = vertices.length / 4;

        // at init time
        const ourTexture = gl.createTexture();
        // insert code it init texture here.

        animateScene(ourTexture, image);
      }

      function resize(canvas) {
        // Look up the size the browser is displaying the canvas.
        var displayWidth = window.innerWidth;
        var displayHeight = window.innerHeight;

        // Check if the canvas has different size and make it the same.
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
        }
      }

      function animateScene(ourTexture, image) {
        // We need an actual window size for correctly viewport setup.
        resize(glCanvas);

        // Setup viewport and clear it with black non transparent colour.
        gl.viewport(0, 0, glCanvas.width, glCanvas.height);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Select a buffer for vertices attributes.
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

        const indexOfTextureUnit = 0;
        gl.activeTexture(gl.TEXTURE0 + indexOfTextureUnit);
        gl.bindTexture(gl.TEXTURE_2D, ourTexture);

        // Enable and setup attributes.
        // gl.enableVertexAttribArray(shaderProgram.attributes["aVertexPosition"]);
        // gl.vertexAttribPointer(shaderProgram.attributes["aVertexPosition"], 2,
        //     gl.FLOAT, false, 4 * 4, 0);
        // gl.enableVertexAttribArray(shaderProgram.attributes["aTexturePosition"]);
        // gl.vertexAttribPointer(shaderProgram.attributes["aTexturePosition"], 2,
        //     gl.FLOAT, false, 4 * 4, 2 * 4);

        // Upload the image into the texture.
        var mipLevel = 0; // the largest mip
        var internalFormat = gl.RGBA; // format we want in the texture
        var srcFormat = gl.RGBA; // format of data we are supplying
        var srcType = gl.UNSIGNED_BYTE; // type of data we are supplying
        gl.texImage2D(
          gl.TEXTURE_2D,
          mipLevel,
          internalFormat,
          srcFormat,
          srcType,
          image
        );

        gl.uniform1f(shaderProgram.uniforms["u_time"], Date.now() - timeStart);
        gl.uniform2f(shaderProgram.uniforms["u_resolution"], 2048, 2048);
        gl.uniform1i(shaderProgram.uniforms["u_texture"], 0);

        // Select shader program.
        gl.useProgram(shaderProgram.program);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexCount);

        window.requestAnimationFrame(function (currentTime) {
          console.log("Animate", Date.now() - timeStart);
          previousTime = currentTime;
          animateScene(ourTexture, image);
        });
      }
    </script>
  </body>
</html>
